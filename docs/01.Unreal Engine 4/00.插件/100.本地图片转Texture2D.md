---
title: 加载本地文件
date: 2021-08-19 08:58:19
tags: 
  - UE4插件
categories: 
  - 
    - UE4
    - 插件
permalink: /pages/b73313/
---
<!--more-->

[UE4C++ 向UTexture2D写入数据并生成UAsset资源](https://www.bilibili.com/video/av584530728/)
[UE4 Image处理工具第一讲：从磁盘读取图片数据转成UTexture2D](https://www.bilibili.com/video/BV1Sf4y1Q7zc)

## 加载本地文件
```C
//FFileHelper
    /**
     * Load a binary file to a dynamic array with two uninitialized bytes at end as padding.
     *
     * @param Result    Receives the contents of the file
     * @param Filename  The file to read
     * @param Flags     Flags to pass to IFileManager::CreateFileReader
    */
    static bool LoadFileToArray( TArray<uint8>& Result, const TCHAR* Filename, uint32 Flags = 0 );

    /**
     * Load a binary file to a dynamic array with two uninitialized bytes at end as padding.
     *
     * @param Result    Receives the contents of the file
     * @param Filename  The file to read
     * @param Flags     Flags to pass to IFileManager::CreateFileReader
    */
    static bool LoadFileToArray( TArray64<uint8>& Result, const TCHAR* Filename, uint32 Flags = 0 );
```
## 加载ImageWrapper模块并确认有效
```C
//FModuleManager
    /**
     * Loads the specified module, checking to ensure it exists.
     *
     * @param InModuleName The base name of the module file.  Should not include path, extension or platform/configuration info.  This is just the "module name" part of the module file name.  Names should be globally unique.
     * @return The loaded module, or nullptr if the load operation failed.
     * @see AbandonModule, IsModuleLoaded, LoadModuleChecked, LoadModulePtr, LoadModuleWithFailureReason, UnloadModule
     */
    IModuleInterface& LoadModuleChecked( const FName InModuleName );
```
## 使用ImageWrapper模块创建图片处理
```C
//FImageWrapperModule
virtual TSharedPtr<IImageWrapper> CreateImageWrapper(const EImageFormat InFormat) override;
```
## 处理图片的二进制数据
```C
//FIcoImageWrapper
virtual bool SetCompressed(const void* InCompressedData, int64 InCompressedSize) override;
```
## 获取颜色数据
```C
//FIcoImageWrapper
//格式通常选择BGRA
virtual bool GetRaw(const ERGBFormat InFormat, int32 InBitDepth, TArray64<uint8>& OutRawData) override;
```
## 创建空白Texture
```C
//UTexture2D
/** creates and initializes a new Texture2D with the requested settings */
    ENGINE_API static class UTexture2D* CreateTransient(int32 InSizeX, int32 InSizeY, EPixelFormat InFormat = PF_B8G8R8A8, const FName InName = NAME_None);
```
## 内存复制
```C
//FMemory
    static FORCEINLINE void* Memcpy(void* Dest, const void* Src, SIZE_T Count)
    {
        return memcpy( Dest, Src, Count );
    }
```


## 总结
> 需要在.Build.cs中添加ImageWrapper模块
```C

bool UTexturesOperation::LoadImageFromUrl(const FString& ImageUrl, UTexture2D*& InTexture)
{
    TArray<uint8> ImageResultData;
    FFileHelper::LoadFileToArray(ImageResultData, *ImageUrl);
    IImageWrapperModule& ImageWrapperModule = FModuleManager::LoadModuleChecked<IImageWrapperModule>("ImageWrapper");
    TSharedPtr<IImageWrapper> ImageWrapperPtr = ImageWrapperModule.CreateImageWrapper(GetImageFormatFromExtension(ImageUrl));

    if (ImageWrapperPtr.IsValid() && ImageWrapperPtr->SetCompressed(ImageResultData.GetData(), ImageResultData.Num()))
    {
        TArray<uint8> OutRawData;
        //8位图片
        if (ImageWrapperPtr->GetRaw(ERGBFormat::BGRA, 8, OutRawData))
        {
            InTexture = UTexture2D::CreateTransient(ImageWrapperPtr->GetWidth(), ImageWrapperPtr->GetHeight());
            if (InTexture)
            {
                void* TextureData = InTexture->PlatformData->Mips[0].BulkData.Lock(LOCK_READ_WRITE);
                FMemory::Memcpy(TextureData, OutRawData.GetData(), OutRawData.Num());
                InTexture->PlatformData->Mips[0].BulkData.Unlock();
                InTexture->UpdateResource();
                return true;
            }
        }

    }
    return false;
}
```
